import streamlit as st
import pandas as pd
from datetime import timedelta, datetime, timezone
from itertools import permutations
from urllib.parse import quote
from zoneinfo import ZoneInfo

st.set_page_config(page_title="Interview Scheduler", layout="wide")
st.title("üìÖ Interview Scheduler Tool")

st.markdown("""
### Instructions
Before using this tool:
1. Generate the interviewer availability CSV using your **Power Automate** flow (15-minute increments).
2. Upload that CSV below (columns: **Interviewer, StartTime, EndTime**).
3. For each interviewer, choose their interview duration (15, 30, 45, or 60 minutes), and enter their email (auto-filled if the name looks like an email).
4. Choose the **maximum agenda options per day** to generate, then click **Generate Agendas**.
---
""")

# -------------------- Helpers for invites --------------------
def outlook_web_link(to_email, start_dt_local, end_dt_local, subject, body="", location=""):
    """
    Outlook on the web compose deeplink with fields pre-filled.
    Supply local (user timezone) datetimes formatted as YYYY-MM-DDTHH:MM:SS
    """
    fmt = "%Y-%m-%dT%H:%M:%S"
    params = {
        "path": "/calendar/action/compose",
        "rru": "addevent",
        "startdt": start_dt_local.strftime(fmt),
        "enddt":   end_dt_local.strftime(fmt),
        "subject": subject,
        "body": body,
        "location": location,
        "to": to_email,
    }
    base = "https://outlook.office.com/calendar/deeplink/compose?"
    q = "&".join(f"{k}={quote(str(v))}" for k, v in params.items() if v is not None)
    return base + q

def make_ics(organizer_email, attendee_email, start_dt_local, end_dt_local):
    """
    Build a simple meeting REQUEST ICS (UTC inside file).
    """
    def fmt_utc(dt):
        return dt.astimezone(timezone.utc).strftime("%Y%m%dT%H%M%SZ")

    dtstamp = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
    uid = f"{int(start_dt_local.timestamp())}-{attendee_email}"

    subject = "Interview"
    body = "Proposed interview slot generated by the Interview Scheduler."
    location = "Teams"

    ics = f"""BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Interview Scheduler//EN
METHOD:REQUEST
BEGIN:VEVENT
UID:{uid}
DTSTAMP:{dtstamp}
DTSTART:{fmt_utc(start_dt_local)}
DTEND:{fmt_utc(end_dt_local)}
SUMMARY:{subject}
DESCRIPTION:{body}
LOCATION:{location}
ORGANIZER;CN=Organizer:mailto:{organizer_email}
ATTENDEE;CN={attendee_email};ROLE=REQ-PARTICIPANT;PARTSTAT=NEEDS-ACTION;RSVP=TRUE:mailto:{attendee_email}
END:VEVENT
END:VCALENDAR
"""
    return ics.encode("utf-8")

uploaded_file = st.file_uploader("Upload CSV from Power Automate", type=["csv"])

def parse_time_series(s):
    return pd.to_datetime(s, errors="coerce", infer_datetime_format=True)

# Organizer & timezone
with st.sidebar:
    st.header("Organizer & Timezone")
    organizer_email = st.text_input("Organizer email", value="you@company.com")
    tz_label = st.selectbox(
        "Your timezone",
        ["America/New_York", "America/Chicago", "America/Denver", "America/Los_Angeles", "UTC"],
        index=0
    )
    USER_TZ = ZoneInfo(tz_label)

if uploaded_file:
    # ---------- Load & normalize ----------
    df = pd.read_csv(uploaded_file)
    df.columns = [c.strip() for c in df.columns]
    if len(df.columns) != 3:
        st.error("CSV must have exactly 3 columns: Interviewer, StartTime, EndTime")
        st.stop()

    df.columns = ["Interviewer", "StartTime", "EndTime"]
    df["Interviewer"] = df["Interviewer"].astype(str).str.strip()

    df["StartTime"] = parse_time_series(df["StartTime"])
    df["EndTime"]   = parse_time_series(df["EndTime"])

    df = df.dropna(subset=["Interviewer", "StartTime", "EndTime"]).copy()

    # floor to 15-min grid
    df["StartTime"] = df["StartTime"].dt.floor("15min")
    df["EndTime"]   = df["EndTime"].dt.floor("15min")

    fifteen = timedelta(minutes=15)
    df.loc[df["EndTime"] <= df["StartTime"], "EndTime"] = df["StartTime"] + fifteen

    # localize to chosen timezone if naive
    if df["StartTime"].dt.tz is None:
        df["StartTime"] = df["StartTime"].dt.tz_localize(USER_TZ)
        df["EndTime"]   = df["EndTime"].dt.tz_localize(USER_TZ)

    df["Date"] = df["StartTime"].dt.date

    # ---------- UI: durations + emails ----------
    interviewers = sorted(df["Interviewer"].unique())
    st.subheader("Set Duration & Email for Each Interviewer")
    cols = st.columns(2)
    left, right = cols[0], cols[1]

    durations = {}
    emails = {}
    for i, person in enumerate(interviewers):
        with left:
            durations[person] = st.selectbox(
                f"{person} ‚Äî duration (mins)",
                [15, 30, 45, 60],
                index=1,
                key=f"d_{person}"
            )
        with right:
            default_email = person if "@" in person else ""
            emails[person] = st.text_input(
                f"{person} ‚Äî email",
                value=default_email,
                key=f"e_{person}"
            )

    max_per_day = st.slider("Maximum number of agenda options per day", 1, 10, 2)

    # ---------- Contiguity helpers ----------
    def build_blocks_map(day_frame):
        blocks = {}
        candidate_starts = set()
        for person, sub in day_frame.groupby("Interviewer"):
            sub = sub.sort_values("StartTime")
            s = set(zip(sub["StartTime"], sub["EndTime"]))
            blocks[person] = s
            candidate_starts |= set(sub["StartTime"].tolist())
        return blocks, sorted(candidate_starts)

    def has_contiguous(block_set, start_ts, minutes):
        steps = minutes // 15
        t = start_ts
        for _ in range(steps):
            if (t, t + fifteen) not in block_set:
                return False
            t += fifteen
        return True

    def find_agendas_contiguous(df_day, durations, max_per_day):
        day_agendas_total = []
        blocks_map, candidate_starts = build_blocks_map(df_day)

        for person in durations.keys():
            if person not in blocks_map or len(blocks_map[person]) == 0:
                return []

        seen_keys = set()

        for order in permutations(durations.keys()):
            if len(day_agendas_total) >= max_per_day:
                break
            for start in candidate_starts:
                if len(day_agendas_total) >= max_per_day:
                    break
                current = start
                agenda = []
                ok = True
                for person in order:
                    need = durations[person]
                    if has_contiguous(blocks_map[person], current, need):
                        agenda.append((person, current, current + timedelta(minutes=need)))
                        current = current + timedelta(minutes=need)
                    else:
                        ok = False
                        break
                if ok:
                    sig = tuple((p, s.isoformat(), e.isoformat()) for p, s, e in agenda)
                    if sig not in seen_keys:
                        seen_keys.add(sig)
                        day_agendas_total.append(agenda)
        return day_agendas_total

    def find_all_days(df, durations, max_per_day):
        agendas_all = []
        for _, day_frame in df.groupby("Date"):
            day_results = find_agendas_contiguous(day_frame, durations, max_per_day)
            agendas_all.extend(day_results)
        return agendas_all

    # ---------- Generate ----------
    if st.button("Generate Agendas"):
        if not interviewers:
            st.error("No interviewers found in the CSV.")
            st.stop()

        agendas = find_all_days(df, durations, max_per_day)

        if not agendas:
            st.error("No valid sequential agendas found. Make sure your CSV has 15-minute rows for each free slice per interviewer.")
        else:
            st.success(f"‚úÖ Found {len(agendas)} possible agendas.")
            html_blocks = []

            subject_prefix = "Interview"
            body_template = "Proposed interview slot generated by the Interview Scheduler."
            location_default = "Teams"

            for idx, agenda in enumerate(agendas, start=1):
                # Header
                date_str = agenda[0][1].astimezone(USER_TZ).strftime("%A, %B %d, %Y")
                st.markdown(f"### Option {idx} ‚Äî {date_str}")

                # Markdown table
                md = "| Interviewer | Start | End |\n|---|---:|---:|\n"
                for person, start_ts, end_ts in agenda:
                    md += f"| {person} | {start_ts.astimezone(USER_TZ).strftime('%I:%M %p')} | {end_ts.astimezone(USER_TZ).strftime('%I:%M %p')} |\n"
                st.markdown(md)

                # Invite actions per row
                st.caption("Create invitations for this option:")
                for person, start_ts, end_ts in agenda:
                    attendee = emails.get(person, person if "@" in person else "")
                    col1, col2, col3 = st.columns([3,2,2])
                    with col1:
                        st.write(f"**{person}** ‚Äî {start_ts.astimezone(USER_TZ).strftime('%I:%M %p')}‚Äì{end_ts.astimezone(USER_TZ).strftime('%I:%M %p')}")
                    with col2:
                        if attendee:
                            owa = outlook_web_link(
                                to_email=attendee,
                                start_dt_local=start_ts.astimezone(USER_TZ).replace(tzinfo=None),
                                end_dt_local=end_ts.astimezone(USER_TZ).replace(tzinfo=None),
                                subject=subject_prefix,
                                body=body_template,
                                location=location_default
                            )
                            st.markdown(f"[Open in Outlook]({owa})", unsafe_allow_html=True)
                        else:
                            st.markdown("*Enter email above to enable Outlook link*")
                    with col3:
                        if organizer_email and attendee:
                            ics_bytes = make_ics(
                                organizer_email=organizer_email,
                                attendee_email=attendee,
                                start_dt_local=start_ts.astimezone(USER_TZ),
                                end_dt_local=end_ts.astimezone(USER_TZ),
                            )
                            st.download_button(
                                label="Download .ics",
                                data=ics_bytes,
                                file_name=f"invite_{person.replace(' ','_')}.ics",
                                mime="text/calendar",
                                key=f"ics_{idx}_{person}"
                            )
                        else:
                            st.markdown("*Enter organizer + attendee email to enable ICS*")

                # For email preview block (unchanged visual summary)
                rows_html = "".join(
                    f"<tr><td>{p}</td><td>{s.astimezone(USER_TZ).strftime('%I:%M %p')}</td><td>{e.astimezone(USER_TZ).strftime('%I:%M %p')}</td></tr>"
                    for p, s, e in agenda
                )
                html_blocks.append(
                    f"""
                    <div style="margin:12px 0;">
                      <h3 style="margin:0 0 6px 0;">Option {idx} ‚Äî {date_str}</h3>
                      <table border="1" cellspacing="0" cellpadding="6" style="border-collapse:collapse;">
                        <tr><th>Interviewer</th><th>Start</th><th>End</th></tr>
                        {rows_html}
                      </table>
                    </div>
                    """
                )

            full_html = "".join(html_blocks)

            st.subheader("üìß Email Preview")
            st.markdown(full_html, unsafe_allow_html=True)

            # Copy HTML button (unchanged)
            safe_html = full_html.replace("\\", "\\\\").replace("`", "\\`")
            copy_component = f"""
            <script>
              async function copyHTML() {{
                const html = `{safe_html}`;
                try {{
                  if (window.ClipboardItem) {{
                    const data = new ClipboardItem({{'text/html': new Blob([html], {{type: 'text/html'}})}});
                    await navigator.clipboard.write([data]);
                  }} else {{
                    await navigator.clipboard.writeText(html);
                  }}
                  const el = document.getElementById("copy-status");
                  if (el) {{ el.innerText = "‚úÖ Copied! Paste into Outlook."; }}
                }} catch (e) {{
                  const el = document.getElementById("copy-status");
                  if (el) {{ el.innerText = "‚ùå Copy failed. Select & copy from the preview."; }}
                }}
              }}
            </script>
            <button onclick="copyHTML()">üìã Copy HTML to Clipboard</button>
            <span id="copy-status" style="margin-left:8px;"></span>
            """
            st.components.v1.html(copy_component, height=60)
